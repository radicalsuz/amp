<?php

/* * * * 
 * AMP_MenuComponent Class
 * allows for recursive construction
 * of menu output
 *
 * this is a base class, and must be extended for functionality
 *
 * Author: austin@radicaldesigns.org
 * 5-29-2005
 ***/


class AMP_MenuComponent {

		// menu refers to the calling array
		var $menu;
		// parent is a reference to the parent object
		var $parent;
		// children contains an array of references to child objects
		var $children;

		// class generated by the BuildMenuSub function
		var $_child_component;
	
		// qualities for the link
		var $id;
		var $href;
		var $label;

		// style values
		var $style = array();
		var $css;
		var $css_template;
		var $css_template_vars;
		
		// templates
		var $template;
		var $core_template = "<a class=\"AMPmenu\" href=\"%1\$s\">%2\$s</a>";
		var $folder_template;

		function AMP_MenuComponent( &$menu, $def ) {
				$this->init( $menu, $def );

		}

		function init( &$menu, $def ) {
                $retain_values = array( "id", "href", "label" );
                foreach ($retain_values as $retain) {
                    if (isset($def[$retain]))  $this->$retain = $def[$retain];
                }

				$this->menu 	= & $menu;
                if (method_exists( $this, '_register_def' )) $this->_register_def( $def );

				if (!$this->hasChildComponent()) $this->setChildComponent( get_class($this) );
		}

		// Create child objects based on the menu_array
		function buildMenuSub ( &$menu_array , $recursive=true  ) {
				if (!isset ($menu_array[$this->id])) return false;
				if (!is_array ($menu_array[$this->id])) return false;

				foreach ($menu_array[$this->id] as $menu_id => $menu_def) {
						$menu_def['id'] = $menu_id;
						if ($child = & $this->addChild( new $this->_child_component ( $this->menu , $menu_def ) )) {
                                #print get_class($this) . 'is building kid ' . $menu_def['label'] .'<BR>';
								if ($recursive) $child->buildMenuSub ( $menu_array );
						}
				}
				#print $this->id . ($this->hasChildren()?" has kids: ".join(", ", array_keys($this->getChildren())).'<BR>':" no kids");

		}

		// default Output routines
		function output($returnChildren=false) {
				$output = sprintf($this->template, $this->id, $this->make_core());
				if ($returnChildren) $output .= $this->outputChildren(); 

				return $output;
		}

		function make_core() {
				return sprintf($this->core_template, $this->href, $this->label);
		}

		function outputChildren($returnChildren=true) {
				return $this->doChildren('output', $returnChildren);
		}


		// set the parent of the object
		function setParent( &$item ) {
				$this->parent = & $item;
		}

		// Functions for manipulation and polling of child objects

		function hasChildren() {
        if (!isset($this->children)) return false;
				return true;
		}

		function &getChildren() {
				$referenceArray = array();
				foreach ($this->children as $id => $aChild) {
						$referenceArray[$id] = &$this->children[$id];
				}
				return $referenceArray;
		}

		function &addChild( &$item ) {
				if (!isset($this->children[$item->id])) {
						$item->setParent( $this );
						return ($this->children[$item->id] = $item);
				}
				//if the designated id slot is already full, add '1' to the end of the
				//ID and try again
				$item->id .= "1";
				return $this->addChild( $item );
		}

		function doChildren ($action, $recursive = true) {
				$output = "";
				if ($this->hasChildren()) {
						$myChildren = & $this->getChildren();
						foreach ($myChildren as $key=>$aChild) {
								if (method_exists($aChild, $action)) {
										$output .= $myChildren[$key]->$action($recursive);
								}
						}
				}
				return $output;
		}

		function &getChild($id) {
				if (isset($id)) {
						
						if ($id == $this->id) return $this;
						if ($this->hasChildren()) {
                                $myChildren = &$this->getChildren();
								foreach ($myChildren as $key => $aChild) {
								    if ($result = &$myChildren[$key]->getChild($id)) return $result;
                                       
								}
						}
						return false;
				}
				return false;
		}

        function setChildComponent( $classname ) {
            if (!class_exists( $classname )) return false;
            $this->_child_component = $classname;
        }

        function hasChildComponent() {
            return (isset($this->_child_component) && ($this->_child_component));
        }
						

		// Functions for managing style information 

        function getStyle() {
            $parent = &$this->menu;
            if ($this->parent) $parent = &$this->parent;

            if (empty($this->style)) {
                return $parent->getStyle();
            }
            return array_merge( $parent->getStyle(), $this->style);
        }
				
		function getCSS($recursive = true) {
				$output = "";
				if ($recursive) $output .= $this->doChildren("getCSS");
				
				return $this->css . $output;
		}

		function setCSS ($recursive = true) {

				if (isset($this->css_template) && is_array($this->css_template_vars)) {
					$this->css=$this->evalCSS();				
				}

				if ($recursive) $this->doChildren('setCSS');
		}

		function evalCSS () {
				if (($styleset = array_combine_key($this->css_template_vars, $this->getStyle()))) {

						if (isset($styleset['id'])) $styleset['id']= $this->id;
						return vsprintf($this->css_template, $styleset);

				}
				return false;
		}



}

?>
